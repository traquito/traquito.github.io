<html>
    <head>
        <title>Spot Decode/Encode CODEC - Traquito</title>
        <link rel="stylesheet" type="text/css" href="/css/traquito.css">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07H1M3KB40"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07H1M3KB40');
</script>

        <script src="/js/sorttable.js"></script>
        <script type='module'>
import * as utl from '/js/Utl.js';
import { WSPREncoded } from '/js/WSPREncoded.js';
import { WsprCodecMaker } from './WsprCodec.js';


export class App
{
    constructor()
    {
        this.codecMaker = new WsprCodecMaker();
        this.domCodec = document.getElementById("codec");
        this.domApplyCodec = document.getElementById("applyCodec");

        this.domEncode = document.getElementById("encode");
        this.domDoEncode = document.getElementById("doEncode");
        this.domResultEncode = document.getElementById("resultEncode");

        this.domDecode = document.getElementById("decode");
        this.domDoDecode = document.getElementById("doDecode");
        this.domResultDecode = document.getElementById("resultDecode");
        

        // override the query default if one exists in the url
        this.OnUrlChange();

        window.addEventListener("popstate", (event) => {
            this.OnUrlChange();
        });

        this.domDoDecode.onclick   = e => { this.DoQuery(); };
        this.domDoEncode.onclick   = this.domDoDecode.onclick;
        this.domApplyCodec.onclick = this.domDoDecode.onclick;
    }

    OnUrlChange()
    {
        utl.SetDomValBySearchParam(this.domCodec,  "codec", this.domCodec.value);
        utl.SetDomValBySearchParam(this.domEncode, "encode", this.domEncode.value.toUpperCase());
        utl.SetDomValBySearchParam(this.domDecode, "decode", this.domDecode.value.toUpperCase());

        this.DoQuery();
    }
    
    DoQuery()
    {
        // update the url with the query so it can be bookmarked or just refereshed
        let encode = this.domEncode.value.toUpperCase();
        let decode = this.domDecode.value.toUpperCase();

        let ok = this.codecMaker.SetCodecDefFragment("MyMessageType", this.domCodec.value);

        if (ok)
        {
            console.log("CODEC GOOD");
        }
        else
        {
            console.log("CODEC BAD");
        }
        
        let codecEncoded  = encodeURIComponent(this.domCodec.value);
        let encodeEncoded = encodeURIComponent(encode);
        let decodeEncoded = encodeURIComponent(decode);
        let newWindowUrl = `${location.pathname}?codec=${codecEncoded}&decode=${decodeEncoded}&encode=${encodeEncoded}`;
        history.pushState({}, "", newWindowUrl);

        if (ok)
        {
            this.DoQueryEncode(encode);
            this.DoQueryDecode(decode);
        }
    }

    DoQueryEncode(query)
    {
        // get encoder
        let e = this.codecMaker.GetCodec();
        const fieldList = e.GetFieldList();

        // clear output
        this.domResultEncode.innerHTML = "";

        // pull in input lines
        let lineList = query.split("\n");
        for (let line of lineList)
        {
            let linePartList = line.trim().split(/\s+/);

            // console.log(linePartList)

            // make sure we have id13 and all fields
            if (linePartList.length == fieldList.length + 1)
            {
                e.Reset();

                // set id13
                e.SetId13(linePartList[0]);

                // set application fields
                for (let i = 0; i < fieldList.length; ++i)
                {
                    let field = fieldList[i];

                    let fn = `Set${field.name}${field.unit}`;
                    // console.log(`${fn}(${linePartList[i + 1]})`)
                    e[fn](linePartList[i + 1]);
                }

                // set header fields
                e.SetHdrTypeEnum(0);            // undefined structure
                e.SetHdrSlotEnum(0);            // first slot
                e.SetHdrTelemetryTypeEnum(0);   // extended telemetry

                // pull out calculated values
                e.Encode();
                let call     = e.GetCall();
                let grid     = e.GetGrid();
                let powerDbm = e.GetPowerDbm();

                this.domResultEncode.innerHTML += `======================================`;
                this.domResultEncode.innerHTML += `\n`;
                this.domResultEncode.innerHTML += `${linePartList.join(" ")}`;
                this.domResultEncode.innerHTML += `\n`;
                this.domResultEncode.innerHTML += `======================================`;
                this.domResultEncode.innerHTML += `\n`;
                this.domResultEncode.innerHTML += `${call} ${grid} ${powerDbm}`;
                this.domResultEncode.innerHTML += `\n`;
                this.domResultEncode.innerHTML += `\n`;
            }
        }
    }

    DoQueryDecode(query)
    {
        let e = this.codecMaker.GetCodec();
        const fieldList = e.GetFieldList();

        // process and output
        this.domResultDecode.innerHTML = "";

        let lineList = query.split("\n");
        for (let line of lineList)
        {
            let linePartList = line.trim().split(/\s+/);
            
            if (linePartList.length == 3)
            {
                let call     = linePartList[0];
                let grid     = linePartList[1];
                let powerDbm = linePartList[2];
                
                console.log(`${call}, ${grid}, ${powerDbm}`);

                this.domResultDecode.innerHTML += `==========================\n`;
                this.domResultDecode.innerHTML += `${call} ${grid} ${powerDbm}` + `\n`;
                this.domResultDecode.innerHTML += `==========================\n`;

                let ret = WSPREncoded.DecodeU4BGridPower(grid, powerDbm);
                
                if (ret.msgType == "standard")
                {
                    let [grid56, altM] = WSPREncoded.DecodeU4BCall(call);
                    let [tempC, voltage, speedKnots, gpsValid] = ret.data;

                    let id1 = call.substring(0, 1);
                    let id3 = call.substring(2, 3);
                    
                    this.domResultDecode.innerHTML += `${id1}${id3} ....${grid56} ${altM} ${tempC} ${voltage} ${speedKnots} ${gpsValid}`   + `\n`;
                    this.domResultDecode.innerHTML += `grid      : ....${grid56}`   + `\n`;
                    this.domResultDecode.innerHTML += `altM      : ${altM}`         + `\n`;
                    this.domResultDecode.innerHTML += `tempC     : ${tempC}`        + `\n`;
                    this.domResultDecode.innerHTML += `voltage   : ${voltage}`      + `\n`;
                    this.domResultDecode.innerHTML += `speedKnots: ${speedKnots}`   + `\n`;
                    this.domResultDecode.innerHTML += `gpsValid  : ${gpsValid}`     + `\n`;
                }
                else
                {
                    e.Reset();

                    e.SetCall(call);
                    e.SetGrid(grid);
                    e.SetPowerDbm(powerDbm);

                    e.Decode();

                    // output headers
                    this.domResultDecode.innerHTML += `Extended telemetry (slot ${e.GetHdrSlotEnum()}, type ${e.GetHdrTypeEnum()})` + `\n`;
                    
                    // calculate field widths
                    let maxFieldName = "id13".length;
                    for (let i = 0; i < fieldList.length; ++i)
                    {
                        let field = fieldList[i];

                        if (field.name.length > maxFieldName)
                        {
                            maxFieldName = field.name.length;
                        }
                    }
                    
                    // output identification fields
                    let id1 = call.substring(0, 1);
                    let id3 = call.substring(2, 3);
                    this.domResultDecode.innerHTML += `${"id13".padEnd(maxFieldName)}: ${id1}${id3}` + `\n`;

                    // output application fields
                    for (let i = 0; i < fieldList.length; ++i)
                    {
                        let field = fieldList[i];

                        let fn = `Get${field.name}${field.unit}`;
                        let val = e[fn](linePartList[i + 1]);

                        this.domResultDecode.innerHTML += `${field.name.padEnd(maxFieldName)}: ${val}` + `\n`;
                    }
                }

                this.domResultDecode.innerHTML += `\n`;
            }
            else
            {
                if (linePartList[0] != "")
                {
                    this.domResultDecode.innerHTML += `==========================\n`;
                    this.domResultDecode.innerHTML += `Skipping invalid line "${line}"\n`;
                    this.domResultDecode.innerHTML += `==========================\n`;
                    this.domResultDecode.innerHTML += `\n`;
                }
            }
        }
    }
}

window.addEventListener('DOMContentLoaded', (event) => {
    let app = new App();
});

</script>

<style>
section {
    display: inline-flex;
}

textarea {
    resize: both;
    height: 300px;
    min-width: 300px;
}

dfn {
    display: inline-block;
    min-width: 130px;
}

.heading {
    font-size: 1.3em;
}

#decode, #encode {
    text-transform: uppercase;
}

#codec {
    height: 150px;
    min-width: 900px;
}
</style>

    </head>
    <body>
        <div class="linkbar">
            <a href="/" target="_blank">Home</a> > <a href="/pro" target="_blank">Pro Tools</a> > Decoder
        </div>

        <span class="heading">
            CODEC JSON
        </span>

        <br/>

<textarea id="codec" spellcheck="false">
{ "name": "Altitude",    "type": "Int",   "unit": "Meters",  "lowValue":   0, "highValue": 21340,    "stepSize": 20    },
{ "name": "Temperature", "type": "Int",   "unit": "Celcius", "lowValue": -50, "highValue":    39,    "stepSize":  1    },
{ "name": "Voltage",     "type": "Float", "unit": "Volts",   "lowValue":   3, "highValue":     4.95, "stepSize":  0.05 },
{ "name": "Speed",       "type": "Int",   "unit": "Knots",   "lowValue":   0, "highValue":    82,    "stepSize":  2    },
{ "name": "IsGpsValid",  "type": "Int",   "unit": "Bool",    "lowValue":   0, "highValue":     1,    "stepSize":  1    },
</textarea>
        <br/>
        <button id="applyCodec">Apply</button>
        <button onclick="window.location = window.location.href.split('?')[0]">Restore Defaults</button>
        <br/>
        <br/>

        <span class="heading">
            Decode: call, grid, power
        </span>
        <br/>
        <section>
            <textarea id="decode" spellcheck="false">
030PAJ DI52 40
1A1TIV AJ60 53
QF2HJF GL09 57

</textarea>
            <button id="doDecode">Click<br/>to<br/>Decode</button>
            <textarea id="resultDecode" spellcheck="false"></textarea>
        </section>

        <br/>
        <br/>

        <br>
        <span class="heading">
            Encode: id13, Altitude, Temperature, Voltage, Speed, IsGpsValid
        </span>
        <br>
        <section>
            <textarea id="encode" spellcheck="false">
00  5000 -55 2.95 -5 -1
11 15000  22 3.15 40 1
q2 22000  45 5.15 95 2

</textarea>
            <button id="doEncode">Click<br/>to<br/>Encode</button>
            <textarea id="resultEncode" spellcheck="false"></textarea>
        </section>
        <br/>
        <br/>
        <br/>
    </body>
</html>
