<html>
    <head>
        <title>Spot Decode/Encode CODEC - Traquito</title>
        <link rel="stylesheet" type="text/css" href="/css/traquito.css">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07H1M3KB40"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07H1M3KB40');
</script>

        <script src="/js/sorttable.js"></script>
        <script type='module'>
import * as utl from '/js/Utl.js';
import { WSPREncoded } from '/js/WSPREncoded.js';


export class WsprCodec
{
    constructor()
    {
        this.codec = "";
        this.json = {};

        this.SetCodecFragment("MyMessageType", "");
    }

    // allow setting just name and fields, don't worry about object structure
    SetCodecFragment(msgName, codecFragment)
    {
        let finalFieldFragment = `
        { "name": "HdrType",         "type": "Int", "unit": "Enum", "lowValue": 0, "highValue": 15, "stepSize": 1 },
        { "name": "HdrSlot",         "type": "Int", "unit": "Enum", "lowValue": 0, "highValue":  3, "stepSize": 1 },
        { "name": "HdrRESERVED",     "type": "Int", "unit": "Enum", "lowValue": 0, "highValue":  3, "stepSize": 1 },
        { "name": "HdrTelemetryStd", "type": "Int", "unit": "Enum", "lowValue": 0, "highValue":  1, "stepSize": 1 }
        `;

        // assumes the input's codeFragment ends with a comma if there are fields
        let codec = `
{
    "name": "${msgName}",
    "fieldList": [${codecFragment} ${finalFieldFragment}]
}`;

        return this.SetCodec(codec);
    }

    SetCodec(codec)
    {
        this.codec = codec;

        return this.ParseCodec(this.codec);
    }

    ParseCodec(codec)
    {
        let ok = true;

        console.log(codec);

        try
        {
            this.json = JSON.parse(codec);

            // validate basic structure
            if ("name" in this.json == false)
            {
                ok = false;
                console.log(`No "name" property for codec`);
            }
            else if ("fieldList" in this.json == false)
            {
                ok = false;
                console.log(`No "fieldList" property for codec`);
            }
            else
            {
                for (const field of this.json.fieldList)
                {
                    if ("name" in field == false)
                    {
                        ok = false;
                        console.log(`No "name" property in field`);
                    }
                    else if ("type" in field == false)
                    {
                        ok = false;
                        console.log(`No "type" property in field(${field.name})`);
                    }
                    else if (field.type == "Int" || field.type == "Float")
                    {
                        // check the right fields exist
                        const propList = [
                            "unit",
                            "lowValue",
                            "highValue",
                            "stepSize",
                        ];

                        for (const prop of propList)
                        {
                            if (prop in field == false)
                            {
                                ok = false;
                                console.log(`No "${prop}"" property in field(${field.name})`);
                            }
                        }

                        // check the fields logically make sense
                        if (ok)
                        {
                            // is there a whole-number number of divisions of the low-to-high
                            // range when incremented by the step size?

                            let stepCount = (field.highValue - field.lowValue) / field.stepSize;

                            if (Number.isInteger(stepCount) == false)
                            {
                                ok = false;
                                console.log(`field(${field.name}) stepSize(${field.stepSize}) does not evenly divide the low(${field.lowValue})-to-high(${field.highValue}) range`);
                            }

                            // check numeric consistency
                            if (field.lowValue >= field.highValue)
                            {
                                ok = false;
                                console.log(`field(${field.name}) lowValue(${field.lowValue}) must be less than highValue(${field.highValue})`);
                            }
                        }
                    }
                    else
                    {
                        ok = false;
                        console.log(`"type" property(${field.type}) in field(${field.name}) unrecognized"`);
                    }
                }
            }
        }
        catch (e)
        {
            console.log(e);
        }

        return ok;
    }

    Calculate()
    {
        // lazy for now
        let bitsLast = 0;
        let bitsSum = 0;
        for (let field of this.json.fieldList)
        {
            field.NumValues = ((field.highValue - field.lowValue) / field.stepSize) + 1;
            field.Bits      = Math.log2(field.NumValues);
            field.BitsSum   = field.Bits + bitsSum;

            bitsLast = field.Bits;
            bitsSum = bitsSum + field.Bits;
        }

        console.table(this.json.fieldList);

        this.GenerateCodecClassCode();
    }

    GetCodecClass()
    {

    }

    GenerateCodecClassCode()
    {
        class Accumulator
        {
            constructor()
            {
                this.str = ``;
                this.indent = 0;
            }

            A(appendStr)
            {
                this.str = `${this.str}${" ".repeat(this.indent)}${appendStr}\n`;
            }

            IncrIndent()
            {
                this.indent += 4;
            }

            DecrIndent()
            {
                this.indent -= 4;
            }

            Get()
            {
                return this.str;
            }
        }

        let a = new Accumulator();


        a.A(`class ${this.json.name}Encoder`);
        a.A(`{`);

        // Constructor
        a.IncrIndent();
        a.A(`constructor()`);
        a.A(`{`);
            a.IncrIndent();
            for (let field of this.json.fieldList)
            {
                if (field.type == "Int")
                {
                    a.A(`this.${field.name} = 0;`);
                }
                else if (field.type == "Float")
                {
                    a.A(`this.${field.name} = 0.0;`);
                }
            }
            a.DecrIndent();
        a.A(`}`);
        a.DecrIndent();

        
        // Setters / Getters
        for (let field of this.json.fieldList)
        {
            a.A(` `);

            // Setter
            a.IncrIndent();
            a.A(`Set${field.name}${field.unit}(inputVal)`);
            a.A(`{`);
                a.IncrIndent();

                a.A(`let val = inputVal ?? ${field.lowValue};`);
                a.A(``);
                a.A(`if (val < ${field.lowValue}) { val = ${field.lowValue}; }`);
                a.A(`if (val > ${field.lowValue}) { val = ${field.highValue}; }`);
                a.A(``);
                a.A(`this.${field.name} = val;`);

                a.DecrIndent();
            a.A(`}`);
            a.DecrIndent();

            a.A(` `);

            // Getter
            a.IncrIndent();
            a.A(`Get${field.name}${field.unit}(inputVal)`);
            a.A(`{`);
                a.IncrIndent();

                a.A(`return this.${field.name};`);

                a.DecrIndent();
            a.A(`}`);
            a.DecrIndent();
        }
            

        a.A(`}`);

        let c = a.Get();

        console.log(c);

        let myClass = new Function('', c);
        console.log(myClass);
        myClass.SetSpeedKnots(50);
        myClass.GetSpeedKnots();
        myClass.SetSpeedKnots(100);
        myClass.GetSpeedKnots(100);

        return c;
    }
}

export class App
{
    constructor()
    {
        this.codec = new WsprCodec();
        this.domCodec = document.getElementById("codec");
        this.domApplyCodec = document.getElementById("applyCodec");

        this.domEncode = document.getElementById("encode");
        this.domDoEncode = document.getElementById("doEncode");
        this.domResultEncode = document.getElementById("resultEncode");

        this.domDecode = document.getElementById("decode");
        this.domDoDecode = document.getElementById("doDecode");
        this.domResultDecode = document.getElementById("resultDecode");
        

        // override the query default if one exists in the url
        this.OnUrlChange();

        window.addEventListener("popstate", (event) => {
            this.OnUrlChange();
        });

        this.domDoDecode.onclick = e => {
            this.DoQuery();
        };

        this.domDoEncode.onclick = this.domDoDecode.onclick;

        this.domApplyCodec.onclick = e => {
            this.DoQuery();

            if (this.codec.SetCodecFragment("MyMessageType", this.domCodec.value))
            {
                console.log("CODEC GOOD");

                this.codec.Calculate();
            }
            else
            {
                console.log("CODEC BAD");
            }
        }

        this.domApplyCodec.onclick();
    }

    OnUrlChange()
    {
        utl.SetDomValBySearchParam(this.domCodec,  "codec", this.domCodec.value);
        utl.SetDomValBySearchParam(this.domEncode, "encode", this.domEncode.value.toUpperCase());
        utl.SetDomValBySearchParam(this.domDecode, "decode", this.domDecode.value.toUpperCase());

        this.DoQuery();
    }
    
    DoQuery()
    {
        WSPREncoded.EnableDebug();

        // update the url with the query so it can be bookmarked or just refereshed
        let codec  = this.domCodec.value;
        let encode = this.domEncode.value.toUpperCase();
        let decode = this.domDecode.value.toUpperCase();
        
        let codecEncoded  = encodeURIComponent(codec);
        let encodeEncoded = encodeURIComponent(encode);
        let decodeEncoded = encodeURIComponent(decode);
        let newWindowUrl = `${location.pathname}?codec=${codecEncoded}&decode=${decodeEncoded}&encode=${encodeEncoded}`;
        history.pushState({}, "", newWindowUrl);

        return;

        this.DoQueryEncode(encode);
        this.DoQueryDecode(decode);
    }

    DoQueryEncode(query)
    {
        // process and output
        this.domResultEncode.innerHTML = "";

        let lineList = query.split("\n");
        for (let line of lineList)
        {
            let linePartList = line.trim().split(/\s+/);
            
            if (linePartList.length == 7)
            {
                let id13       = linePartList[0];
                let gridIn     = linePartList[1];
                let altM       = linePartList[2];
                let tempC      = linePartList[3];
                let voltage    = linePartList[4];
                let speedKnots = linePartList[5];
                let gpsValid   = linePartList[6];

                let id1   = id13.substring(0, 1);
                let id3   = id13.substring(1);
                let grid5 = gridIn.substring(4, 5);
                let grid6 = gridIn.substring(5);

                let gridIn56 = grid5 + grid6;
                
                console.log(`${gridIn}, ${gridIn56}, ${altM}`);

                this.domResultEncode.innerHTML += `===============================\n`;
                this.domResultEncode.innerHTML += `${id13} ${gridIn} ${altM} ${tempC} ${voltage} ${speedKnots} ${gpsValid}` + `\n`;
                this.domResultEncode.innerHTML += `===============================\n`;

                let call = WSPREncoded.EncodeU4BCall(id1, id3, gridIn56, altM);
                let [grid, power] = WSPREncoded.EncodeU4BGridPower(tempC, voltage, speedKnots, gpsValid);

                this.domResultEncode.innerHTML += `${call} ${grid} ${power}` + `\n`;
                this.domResultEncode.innerHTML += `call : ${call}`  + `\n`;
                this.domResultEncode.innerHTML += `grid : ${grid}`  + `\n`;
                this.domResultEncode.innerHTML += `power: ${power}` + `\n`;
                this.domResultEncode.innerHTML += `\n`;
            }
            else
            {
                if (linePartList[0] != "")
                {
                    this.domResultEncode.innerHTML += `==========================\n`;
                    this.domResultEncode.innerHTML += `Skipping invalid line "${line}"\n`;
                    this.domResultEncode.innerHTML += `==========================\n`;
                    this.domResultEncode.innerHTML += `\n`;
                }
            }
        }
    }

    DoQueryDecode(query)
    {
        // process and output
        this.domResultDecode.innerHTML = "";

        let lineList = query.split("\n");
        for (let line of lineList)
        {
            let linePartList = line.trim().split(/\s+/);
            
            if (linePartList.length == 3)
            {
                let call  = linePartList[0];
                let grid  = linePartList[1];
                let power = linePartList[2];
                
                console.log(`${call}, ${grid}, ${power}`);

                this.domResultDecode.innerHTML += `==========================\n`;
                this.domResultDecode.innerHTML += `${call} ${grid} ${power}` + `\n`;
                this.domResultDecode.innerHTML += `==========================\n`;

                let ret = WSPREncoded.DecodeU4BGridPower(grid, power);
                
                if (ret.msgType == "standard")
                {
                    let [grid56, altM] = WSPREncoded.DecodeU4BCall(call);
                    let [tempC, voltage, speedKnots, gpsValid] = ret.data;

                    let id1 = call.substring(0, 1);
                    let id3 = call.substring(2, 3);
                    
                    this.domResultDecode.innerHTML += `${id1}${id3} ....${grid56} ${altM} ${tempC} ${voltage} ${speedKnots} ${gpsValid}`   + `\n`;
                    this.domResultDecode.innerHTML += `grid      : ....${grid56}`   + `\n`;
                    this.domResultDecode.innerHTML += `altM      : ${altM}`         + `\n`;
                    this.domResultDecode.innerHTML += `tempC     : ${tempC}`        + `\n`;
                    this.domResultDecode.innerHTML += `voltage   : ${voltage}`      + `\n`;
                    this.domResultDecode.innerHTML += `speedKnots: ${speedKnots}`   + `\n`;
                    this.domResultDecode.innerHTML += `gpsValid  : ${gpsValid}`     + `\n`;
                }
                else
                {
                    this.domResultDecode.innerHTML += `type : ${ret.msgType}\t- non-standardized telemetry` + `\n`;
                    this.domResultDecode.innerHTML += `seq  : ${ret.msgSeq}\t- first or second in series`  + `\n`;
                }

                this.domResultDecode.innerHTML += `\n`;
            }
            else
            {
                if (linePartList[0] != "")
                {
                    this.domResultDecode.innerHTML += `==========================\n`;
                    this.domResultDecode.innerHTML += `Skipping invalid line "${line}"\n`;
                    this.domResultDecode.innerHTML += `==========================\n`;
                    this.domResultDecode.innerHTML += `\n`;
                }
            }
        }
    }
}

window.addEventListener('DOMContentLoaded', (event) => {
    let app = new App();
});

</script>

<style>
section {
    display: inline-flex;
}

textarea {
    resize: both;
    height: 300px;
    min-width: 300px;
}

dfn {
    display: inline-block;
    min-width: 130px;
}

.heading {
    font-size: 1.3em;
}

#decode, #encode {
    text-transform: uppercase;
}

#codec {
    height: 150px;
    min-width: 900px;
}
</style>

    </head>
    <body>
        <div class="linkbar">
            <a href="/" target="_blank">Home</a> > <a href="/pro" target="_blank">Pro Tools</a> > Decoder
        </div>

        <span class="heading">
            CODEC JSON
        </span>

        <br/>

<textarea id="codec" spellcheck="false">
{ "name": "Altitude",    "type": "Int",   "unit": "Meters",  "lowValue":   0, "highValue": 21340,    "stepSize": 20    },
{ "name": "Temperature", "type": "Int",   "unit": "Celcius", "lowValue": -50, "highValue":    39,    "stepSize":  1    },
{ "name": "Voltage",     "type": "Float", "unit": "Volts",   "lowValue":   3, "highValue":     4.95, "stepSize":  0.05 },
{ "name": "Speed",       "type": "Int",   "unit": "Knots",   "lowValue":   0, "highValue":    82,    "stepSize":  2    },
{ "name": "IsGpsValid",  "type": "Int",   "unit": "Bool",    "lowValue":   0, "highValue":     1,    "stepSize":  1    },
</textarea>
        <br/>
        <button id="applyCodec">Apply</button>
        <button onclick="window.location = window.location.href.split('?')[0]">Restore Defaults</button>
        <br/>
        <br/>

        <span class="heading">
            Decode: call, grid, power
        </span>
        <br/>
        <section>
            <textarea id="decode" spellcheck="false">
1Y4PAS HK08 10
QX7DGS JQ97 33
0X2FDM MI65 27

</textarea>
            <button id="doDecode">Click<br/>to<br/>Decode</button>
            <textarea id="resultDecode" spellcheck="false"></textarea>
        </section>

        <br/>
        <br/>

        <br>
        <span class="heading">
            Encode: id13, 6-char maidenhead, altitudeMeters, tempC, voltage, speedKnots, gpsValid
        </span>
        <br>
        <section>
            <textarea id="encode" spellcheck="false">
14 FN20XR 1000 -12 4.95  0 1
Q7 FN20WR 3000   0 3.18 10 0
02 FN20WS 7000  13 3.00 60 1

</textarea>
            <button id="doEncode">Click<br/>to<br/>Encode</button>
            <textarea id="resultEncode" spellcheck="false"></textarea>
        </section>
        <br/>
        <br/>
        <br/>
    </body>
</html>
